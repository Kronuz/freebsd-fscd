# This is a shell archive.  Save it in a file, remove anything before
# this line, and then unpack it by entering "sh file".  Note, it may
# create directories; files and directories will be owned by you and
# have default permissions.
#
# This archive contains:
#
#	fsc
#	fsc/Makefile
#	fsc/files
#	fsc/files/patch-fscd__fscd.c
#	fsc/files/patch-fscadm__fscadm.c
#	fsc/files/patch-rc.d_fscd
#	fsc/distinfo
#	fsc/pkg-descr
#
echo c - fsc
mkdir -p fsc > /dev/null 2>&1
echo x - fsc/Makefile
sed 's/^X//' >fsc/Makefile << 'END-of-fsc/Makefile'
X# Created by: Tom Rhodes <trhodes@FreeBSD.org>
X# $FreeBSD: head/sysutils/fsc/Makefile 386312 2015-05-14 10:15:04Z mat $
X
XPORTNAME=	fsc
XDISTVERSION=	1.0.1
XPORTVERSION=	1.2.0
XPORTREVISION=	0
XCATEGORIES=	sysutils
XMASTER_SITES=	LOCAL/trhodes
X
XMAINTAINER=	trhodes@FreeBSD.org
XCOMMENT=	The FreeBSD Services Control family of utilities
X
XWRKSRC=		${WRKDIR}/fsc
X
XPLIST_FILES=	bin/fscadm sbin/fscd etc/rc.d/fscd man/man5/fscd.conf.5.gz \
X		man/man8/fscadm.8.gz man/man8/fscd.8.gz
X
Xpost-patch:
X	@${REINPLACE_CMD} -e 's|/etc|${PREFIX}/etc|' \
X		${WRKSRC}/fscd/fscd.8 ${WRKSRC}/fscd/fscd.c \
X		${WRKSRC}/fscd/fscd.conf.5 ${WRKSRC}/fscadm/fscadm.c
X
Xdo-install:
X	${INSTALL_PROGRAM} ${WRKSRC}/fscadm/fscadm ${STAGEDIR}${PREFIX}/bin
X	${INSTALL_PROGRAM} ${WRKSRC}/fscd/fscd ${STAGEDIR}${PREFIX}/sbin
X	${INSTALL_SCRIPT} ${WRKSRC}/rc.d/fscd ${STAGEDIR}${PREFIX}/etc/rc.d
X	${INSTALL_DATA} ${WRKSRC}/fscd/fscd.conf.5.gz \
X		${STAGEDIR}${MANPREFIX}/man/man5
X	${INSTALL_DATA} ${WRKSRC}/fscd/fscd.8.gz \
X		${STAGEDIR}${MANPREFIX}/man/man8
X	${INSTALL_DATA} ${WRKSRC}/fscadm/fscadm.8.gz \
X		${STAGEDIR}${MANPREFIX}/man/man8
X
X.include <bsd.port.mk>
END-of-fsc/Makefile
echo c - fsc/files
mkdir -p fsc/files > /dev/null 2>&1
echo x - fsc/files/patch-fscd__fscd.c
sed 's/^X//' >fsc/files/patch-fscd__fscd.c << 'END-of-fsc/files/patch-fscd__fscd.c'
Xdiff --git a/fscd/fscd.c b/fscd/fscd.c
Xindex 2c915ce..a1d6bce 100644
X--- fscd/fscd.c
X+++ fscd/fscd.c
X@@ -22,7 +22,7 @@
X  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X  * SUCH DAMAGE.
X  *
X- * $Id: fscd.c 2063 2013-06-03 14:03:41Z bsdtrhodes $
X+ * $Id: fscd.c 2076 2014-10-05 01:24:54Z bsdtrhodes $
X  */
X 
X /*
X@@ -48,6 +48,7 @@ __FBSDID("$FreeBSD$");
X #include <sys/user.h>
X #include <sys/time.h>
X #include <sys/wait.h>
X+
X #include <ctype.h>
X #include <err.h>
X #include <errno.h>
X@@ -71,8 +72,6 @@ __FBSDID("$FreeBSD$");
X #include <util.h>
X #endif
X 
X-#define DEBUGPRINT(...) if (debug) printlog(LOG_ERR, __VA_ARGS__);
X-
X /* Portability to pkgsrc. */
X #ifndef SYSCONFDIR
X #define SYSCONFDIR "/etc/"
X@@ -82,9 +81,8 @@ __FBSDID("$FreeBSD$");
X #define CONF_FILE SYSCONFDIR"fscd.conf"
X #define SERVICE "service"
X #define STATUS "onestatus"
X-#define START "onestart"
X-#define RESTART "onerestart" // restart is more reliable than just start.
X-#define VERSION "1.1"
X+#define START "restart" // restart is more reliable than just start.
X+#define VERSION "1.2"
X 
X struct spid {
X 	pid_t svpid;
X@@ -109,11 +107,20 @@ struct fscd_cfg {
X 	int kq;
X };
X 
X-static int debug = 0;
X+struct restart_params {
X+	struct fscd_cfg *config;
X+	char *sname;
X+};
X+
X+#if defined(__FreeBSD__)
X+	static struct pidfh *pfh = NULL;
X+#endif
X+
X+static int daemonize = 0;
X static char *socketname = NULL;
X static char *conffile = NULL;
X 
X-static void fscd_shutdown(struct fscd_cfg *, int);
X+static void fscd_shutdown(int);
X static int readconf(struct fscd_cfg *);
X static int print_status(struct fscd_cfg *, int);
X static int handle_restart(struct fscd_cfg *, char *);
X@@ -127,7 +134,7 @@ static void handle_queue(struct fscd_cfg *, struct kevent *);
X static void handle_sig(int);
X static void ignore_sig(int);
X static void printlog(int, const char *, ...);
X-static int process_exited(const int, const struct service *);
X+static int process_exited(const int);
X static int service_registered(struct fscd_cfg *, const char *);
X static int service_running(const char *);
X static struct service *make_service(const char *);
X@@ -146,10 +153,7 @@ main(int argc, char *argv[])
X 	struct kevent kq_events;
X 	struct stat nb_stat;
X 	char errorstr[LINE_MAX];
X-
X-#if defined(__FreeBSD__)
X-	struct pidfh *pfh;
X-#endif
X+	int verbosity = 0;
X 
X 	/* check arguments */
X 	while ((ch = getopt(argc, argv, "Vdvfs:c:")) != -1)
X@@ -157,12 +161,15 @@ main(int argc, char *argv[])
X 			case 'V': /* Print version string. */
X 				version();
X 				break;
X+			case 'd': /* Daemonize. */
X+				daemonize = 1;
X+				break;
X 			case 'c': /* Change config file */
X 				if (asprintf(&conffile, "%s", optarg) <= 0)
X 					err(1, "asprintf");
X 				break;
X-			case 'v': /* Debugging mode. */
X-				debug = 1;
X+			case 'v': /* Verbosity. */
X+				++verbosity;
X 				break;
X 			case 'f': /* Force overwrite. */
X 				force = 1;
X@@ -178,6 +185,21 @@ main(int argc, char *argv[])
X 	argc -= optind;
X 	argv += optind;
X 
X+	switch (verbosity) {
X+		case 0:
X+			setlogmask(LOG_UPTO(LOG_WARNING));
X+			break;
X+		case 1:
X+			setlogmask(LOG_UPTO(LOG_NOTICE));
X+			break;
X+		case 2:
X+			setlogmask(LOG_UPTO(LOG_INFO));
X+			break;
X+		default:
X+			setlogmask(LOG_UPTO(LOG_DEBUG));
X+			break;
X+	}
X+
X 	/* initialize values */
X 	if (!socketname && asprintf(&socketname, "%s", SOCK_PATH) <= 0)
X 		err(1, "asprintf");
X@@ -187,7 +209,7 @@ main(int argc, char *argv[])
X 		warn("cannot stat configuration");
X 	if (stat(socketname, &nb_stat) == 0) {
X 		if (!force)
X-			err(1, "socket exists, specify f to overwrite");
X+			err(1, "socket exists, specify -f to overwrite");
X 		else if (unlink(socketname) == -1)
X 			err(1, "deleting old socket");
X 	}
X@@ -196,12 +218,10 @@ main(int argc, char *argv[])
X 	if ((pfh = pidfile_open(NULL, 0644, NULL)) == NULL)
X 		err(1, "pidfile_open");
X #endif
X-/*
X-	if (debug)
X-		printf("Debug mode. Not daemonizing.\n");
X-	else if (daemon(0, 0) == -1)
X+
X+	if (daemonize && daemon(0, 0) == -1)
X 		err(1, "daemon");
X-*/
X+
X #if defined(__FreeBSD__)
X 	if (pidfile_write(pfh) == -1)
X 		err(1, "pidfile_write");
X@@ -230,12 +250,16 @@ main(int argc, char *argv[])
X 	signal(SIGUSR1, handle_sig);
X 	signal(SIGUSR2, handle_sig);
X 
X+	printlog(LOG_NOTICE, "Starting.");
X+
X 	monthrint = pthread_create(&(config.service_thr), NULL,
X 	    connect_monitor, &config);
X 
X 	/* Read configuration */
X 	readconf(&config);
X 
X+	printlog(LOG_INFO, "Monitoring processes...");
X+
X 	while (1) {
X 		newevent = kevent(config.kq, NULL, 0, &kq_events, 1, NULL);
X 		if (newevent == 1) {
X@@ -269,22 +293,27 @@ handle_queue(struct fscd_cfg *config, struct kevent *kq_events)
X 			if (kq_events->ident == (uintptr_t)svpid->svpid) {
X 				status = kq_events->data;
X 				if (WIFSIGNALED(status)) {
X-					printlog(LOG_ERR, "%s caught signal %d and exited", svs->svname,
X+					printlog(LOG_ERR, "%s caught signal %d"
X+					    " and exited", svs->svname,
X 					    WTERMSIG(status));
X-					pretcode = process_exited(status, svs);
X+					pretcode = process_exited(status);
X 				} else if (WIFEXITED(status)) {
X-					printlog(LOG_ERR, "%s exited with status %d",
X-							svs->svname, WEXITSTATUS(status));
X+					printlog(LOG_ERR, "%s exited with "
X+					    "status %d",
X+					    svs->svname, WEXITSTATUS(status));
X 					pretcode = 0;
X 				} else {
X 					continue;
X 				}
X 
X-				if (pretcode == 1 && handle_restart(config, svs->svname) == 0) {
X+				if (pretcode == 1 && handle_restart(config,
X+				    svs->svname) == 0) {
X 					printlog(LOG_ERR, "%s was restarted",
X 					    svs->svname);
X-				} else if (pretcode == 0 && handle_waiting(config, svs->svname) == 0) {
X-					printlog(LOG_ERR, "Waiting for %s to restart.", svs->svname);
X+				} else if (pretcode == 0 && handle_waiting(config,
X+				    svs->svname) == 0) {
X+					printlog(LOG_ERR, "%s waiting for restart.",
X+					    svs->svname);
X 				} else {
X 					printlog(LOG_ERR, "%s failed to restart.",
X 							svs->svname);
X@@ -301,11 +330,11 @@ handle_queue(struct fscd_cfg *config, struct kevent *kq_events)
X }
X 
X /*
X- * Determine the status of the exited process. If it is a signal which is likely 
X+ * Determine the status of the exited process. If it is a signal which is likely
X  * to be user-issued, return 0, 1 otherwise.
X  */
X static int
X-process_exited(int status, const struct service *svs)
X+process_exited(int status)
X {
X 	switch (WTERMSIG(status)) {
X 		case SIGINT:
X@@ -325,6 +354,7 @@ process_exited(int status, const struct service *svs)
X static int
X handle_restart(struct fscd_cfg *config, char *sname)
X {
X+	int ret;
X 	struct service *svs;
X 	struct spid *svpid;
X 
X@@ -338,20 +368,27 @@ handle_restart(struct fscd_cfg *config, char *sname)
X 			free(svpid);
X 		}
X 
X-		if (start_service(svs)) {
X-			printlog(LOG_ERR, "Could not restart service.");
X-			return -1;
X-		} else if (fill_pids(svs)) {
X+		if ((ret=start_service(svs))) {
X+			if (ret < 0)
X+				printlog(LOG_ERR, "%s could not be restarted.",
X+				    svs->svname);
X+			else
X+				printlog(LOG_ERR, "%s could not be restarted. Set "
X+				    "%s_enable to YES in %cetc/rc.conf.",
X+				    svs->svname, svs->svname, '/');
X+			return ret;
X+		} else if ((ret=fill_pids(svs))) {
X 			printlog(LOG_ERR, "Could not get pids for service.");
X-			return -1;
X+			return ret;
X 		} else if (kqueue_service(config, svs)) {
X 			printlog(LOG_ERR, "Could not monitor service.");
X 			return -1;
X 		}
X-		break;
X+
X+		return 0;
X 	}
X 
X-	return 0;
X+	return -1;
X }
X 
X /*
X@@ -361,14 +398,12 @@ static int
X handle_waiting(struct fscd_cfg *config, char *sname)
X {
X 	pthread_t tmpthr;
X-	struct  {
X-		struct fscd_cfg *cfg;
X-		char *name;
X-	} tmpv;
X-
X-	tmpv.cfg = config;
X-	tmpv.name = sname;
X-	return pthread_create(&tmpthr, NULL, wait_restart, &tmpv);
X+	struct restart_params *inputv;
X+
X+	inputv = malloc(sizeof(struct restart_params));
X+	inputv->config = config;
X+	inputv->sname = strdup(sname);
X+	return pthread_create(&tmpthr, NULL, wait_restart, inputv);
X }
X 
X /*
X@@ -377,10 +412,7 @@ handle_waiting(struct fscd_cfg *config, char *sname)
X static void *
X wait_restart(void *var)
X {
X-	struct {
X-		struct fscd_cfg *config;
X-		char *sname;
X-	} *inputv;
X+	struct restart_params *inputv;
X 	struct service *svs;
X 	struct spid *svpid;
X 	int retries;
X@@ -399,34 +431,48 @@ wait_restart(void *var)
X 
X 			/* Wait for 100 seconds for the service to restart. */
X 			pthread_mutex_lock(&inputv->config->service_mtx);
X-			if (fill_pids(svs) == 0) {
X+			if (!fill_pids(svs)) {
X 				if (kqueue_service(inputv->config, svs))
X-					printlog(LOG_ERR, "Could not monitor service.");
X+					printlog(LOG_ERR, "Could not monitor "
X+					    "service.");
X 				else
X-					printlog(LOG_INFO, "Service %s was restarted, but not by me.",
X-							svs->svname);
X+					printlog(LOG_INFO, "Service %s was "
X+					    "restarted, but not by me.",
X+					    svs->svname);
X 				pthread_mutex_unlock(&inputv->config->service_mtx);
X+				free(inputv->sname);
X+				free(inputv);
X 				return NULL;
X 			}
X 			pthread_mutex_unlock(&inputv->config->service_mtx);
X 			break;
X 		}
X 		if (!svs) {
X-			printlog(LOG_ERR, "Service %s was removed from monitoring \
X-while I was waiting for it to restart.", inputv->sname);
X+			printlog(LOG_ERR, "Service %s was removed from "
X+			    "monitoring while I was waiting for it to restart.",
X+			    inputv->sname);
X+			free(inputv->sname);
X+			free(inputv);
X 			return NULL;
X 		}
X 		sleep(10);
X 	}
X-	printlog(LOG_ERR, "Service %s was not restarted. Doing it myself.", 
X-	    inputv->sname);
X+	printlog(LOG_ERR, "Service %s was not restarted. Doing it myself.",
X+	    svs->svname);
X 	pthread_mutex_lock(&inputv->config->service_mtx);
X-	handle_restart(inputv->config, inputv->sname);
X+	if (handle_restart(inputv->config, svs->svname) == 0) {
X+		printlog(LOG_ERR, "%s was restarted",
X+			svs->svname);
X+	} else {
X+		printlog(LOG_ERR, "%s failed to restart.",
X+				svs->svname);
X+		printlog(LOG_ERR, "%s removed from monitoring.",
X+				svs->svname);
X+		unregister_service(inputv->config, svs->svname);
X+	}
X 	pthread_mutex_unlock(&inputv->config->service_mtx);
X-	return NULL;
X-	
X-	printlog(LOG_ERR, "Service %s should be waited for, but was not found.",
X-	    inputv->sname);
X+	free(inputv->sname);
X+	free(inputv);
X 	return NULL;
X }
X 
X@@ -441,6 +487,9 @@ print_status(struct fscd_cfg *config, int sock_fd)
X 	char *statstream;
X 	char errorstr[LINE_MAX];
X 	char eot = 4;
X+	char status = 0;
X+
X+	send(sock_fd, &status, 1, 0);
X 
X 	/* Our own pid. */
X 	if (asprintf(&statstream, "The fscd pid is %d.\n", getpid()) <= 0) {
X@@ -459,7 +508,8 @@ print_status(struct fscd_cfg *config, int sock_fd)
X 	}
X 
X 	/* Monitored pids header. */
X-	if (asprintf(&statstream, "%-40s %s\n--------------------------------------------------\n", "process name", "pid") <= 0) {
X+	if (asprintf(&statstream, "%-40s %s\n-------------------------------"
X+	    "-------------------\n", "process name", "pid") <= 0) {
X 		if (strerror_r(errno, errorstr, sizeof errorstr))
X 			printlog(LOG_ERR, "asprintf failed.");
X 		else
X@@ -477,21 +527,29 @@ print_status(struct fscd_cfg *config, int sock_fd)
X 	/* Monitored pids. */
X 	SLIST_FOREACH(svs, &config->service_list, next) {
X 		SLIST_FOREACH(svpid, &svs->svpids, next) {
X-			if (asprintf(&statstream, "%-40s %d\n", svs->svname, svpid->svpid) > 0) {
X-				if (send(sock_fd, statstream, strlen(statstream), 0) == -1) {
X-					if (strerror_r(errno, errorstr, sizeof errorstr))
X-						printlog(LOG_ERR, "send failed.");
X+			if (asprintf(&statstream, "%-40s %d\n",
X+			    svs->svname, svpid->svpid) > 0) {
X+				if (send(sock_fd, statstream,
X+				    strlen(statstream), 0) == -1) {
X+					if (strerror_r(errno, errorstr,
X+					    sizeof errorstr))
X+						printlog(LOG_ERR,
X+						    "send failed.");
X 					else
X-						printlog(LOG_ERR, "send: %s", errorstr);
X+						printlog(LOG_ERR,
X+						    "send: %s", errorstr);
X 					free(statstream);
X 					break;
X 				}
X 				free(statstream);
X 			} else {
X-				if (strerror_r(errno, errorstr, sizeof errorstr))
X-					printlog(LOG_ERR, "asprintf for send failed.");
X+				if (strerror_r(errno, errorstr,
X+				    sizeof errorstr))
X+					printlog(LOG_ERR, "asprintf for send "
X+					    "failed.");
X 				else
X-					printlog(LOG_ERR, "asprintf for send failed: %s", errorstr);
X+					printlog(LOG_ERR, "asprintf for send "
X+					    "failed: %s", errorstr);
X 			}
X 		}
X 	}
X@@ -508,7 +566,8 @@ usage(void)
X 	fprintf(stderr, "usage: fscd\n"
X 					"options:\n"
X 					"	-V   Show version info.\n"
X-					"	-v   Debugging: Don't fork.\n"
X+					"	-d   Daemonize.\n"
X+					"	-v   Verbosity, use multiple times.\n"
X 					"	-s S Use socket S.\n"
X 					"	-c C Use config file C.\n");
X 	exit(EX_USAGE);
X@@ -535,20 +594,15 @@ printlog(int priority, const char *logstr, ...)
X 
X 	va_start(tmplist, logstr);
X 
X-	if (debug) {
X-		vfprintf(stdout, logstr, tmplist);
X-		fprintf(stdout, "\n");
X-	} else {
X-		vsyslog(priority, logstr, tmplist);
X-	}
X+	vsyslog(priority, logstr, tmplist);
X 
X 	va_end(tmplist);
X 	return;
X }
X 
X /*
X- * Check whether a service given by sname is running. We use service(8) for
X- * that. It knows best about the running specifica of the service.
X+ * Check whether a service given by sname is running. We use service(8)
X+ * for that. It knows best about the running specifica of the service.
X  */
X static int
X service_running(const char *sname)
X@@ -559,18 +613,20 @@ service_running(const char *sname)
X 
X 	if (asprintf(&cmdstr, SERVICE " %s " STATUS, sname) <= 0) {
X 		if (strerror_r(errno, errorstr, sizeof errorstr))
X-			printlog(LOG_ERR, "asprintf for checking state of %s failed: %s", sname, errorstr);
X+			printlog(LOG_ERR, "asprintf for checking state of %s "
X+			    "failed: %s", sname, errorstr);
X 		else
X-			printlog(LOG_ERR, "asprintf for checking state of %s failed.", sname);
X+			printlog(LOG_ERR, "asprintf for checking state of %s "
X+			    "failed.", sname);
X 		return 0;
X 	}
X 
X 	retcode = system(cmdstr);
X 	free(cmdstr);
X-	if (WEXITSTATUS(retcode) == 0)
X-		return 1;
X-	else
X+	if (WEXITSTATUS(retcode))
X 		return 0;
X+	else
X+		return 1;
X }
X 
X /*
X@@ -604,7 +660,8 @@ make_service(const char *sname)
X 	svs = malloc(sizeof(struct service));
X 	if (!svs) {
X 		if (strerror_r(errno, errorstr, sizeof errorstr))
X-			printlog(LOG_ERR, "malloc for %s failed:", svs->svname, errorstr);
X+			printlog(LOG_ERR, "malloc for %s failed:", svs->svname,
X+			    errorstr);
X 		else
X 			printlog(LOG_ERR, "malloc for %s failed.", svs->svname);
X 		return NULL;
X@@ -612,21 +669,22 @@ make_service(const char *sname)
X 
X 	if (asprintf(&svs->svname, "%s", sname) <= 0) {
X 		if (strerror_r(errno, errorstr, sizeof errorstr))
X-			printlog(LOG_ERR, "asprintf for %s failed:", svs->svname, errorstr);
X+			printlog(LOG_ERR, "asprintf for %s failed:",
X+			    svs->svname, errorstr);
X 		else
X-			printlog(LOG_ERR, "asprintf for %s failed.", svs->svname);
X+			printlog(LOG_ERR, "asprintf for %s failed.",
X+			    svs->svname);
X 		free(svs);
X 		return NULL;
X 	}
X-
X 	SLIST_INIT(&svs->svpids);
X 
X 	return svs;
X }
X 
X /*
X- * Get the pids for given process, and fill the structs, emptying the list if it
X- * is not empty.
X+ * Get the pids for given process, and fill the structs, emptying the
X+ * list if it is not empty.
X  * Return 0 if process is running and we filled pids, 1 if not.
X  */
X static int
X@@ -639,6 +697,8 @@ fill_pids(struct service *svs)
X 	char pinput[LINE_MAX];
X 	char errorstr[LINE_MAX];
X 	FILE *pp;
X+	int retcode;
X+	pid_t pid;
X 
X 	/* Empty list. */
X 	if (!SLIST_EMPTY(&svs->svpids)) {
X@@ -650,7 +710,8 @@ fill_pids(struct service *svs)
X 
X 	if (asprintf(&cmdstr, SERVICE " %s " STATUS, svs->svname) <= 0) {
X 		if (strerror_r(errno, errorstr, sizeof errorstr))
X-			printlog(LOG_ERR, "asprintf failed: %s", svs->svname, errorstr);
X+			printlog(LOG_ERR, "asprintf failed: %s", svs->svname,
X+			    errorstr);
X 		else
X 			printlog(LOG_ERR, "asprintf failed.", svs->svname);
X 		return -1;
X@@ -660,56 +721,49 @@ fill_pids(struct service *svs)
X 	free(cmdstr);
X 	if (pp == NULL) {
X 		if (strerror_r(errno, errorstr, sizeof errorstr))
X-			printlog(LOG_ERR, "popen failed: %s", svs->svname, errorstr);
X+			printlog(LOG_ERR, "popen failed: %s", svs->svname,
X+			    errorstr);
X 		else
X 			printlog(LOG_ERR, "popen failed.", svs->svname);
X 		return -1;
X 	}
X 
X-	if (fgets(pinput, sizeof pinput, pp) == NULL) {
X-		if (strerror_r(errno, errorstr, sizeof errorstr))
X-			printlog(LOG_ERR, "fgets failed: %s", svs->svname, errorstr);
X-		else
X-			printlog(LOG_ERR, "fgets failed.", svs->svname);
X-		pclose(pp);
X-		return -1;
X+	while (fgets(pinput, sizeof pinput, pp) != NULL) {
X+		if (strstr(pinput, "_enable to YES in") != NULL) {
X+			pclose(pp);
X+			return 1;
X+		}
X+
X+		/* Scan the output for a separated list of numbers assuming
X+		 * they are pids.  We cannot scan for the service's name, as
X+		 * the name might be different to the service script name.
X+		 * Though we could assume the service name is properly set
X+		 * in its rc script and we could thus just parse the script
X+		 * ourselves, exceptions here might have the same probability
X+		 * as services with different service and script names
X+		 * So we have to skip the first portion up to the
X+		 * "is not running" or "is runnind as pid" and assume
X+		 * service(8) returns the right script's output.
X+		 */
X+		for (pinputp = strtok_r(pinput, " .,\t\n", &ttmpstr);
X+				pinputp;
X+				pinputp = strtok_r(NULL, " .,\t\n", &ttmpstr)) {
X+			pid = strtoul(pinputp, &tmpstr, 10);
X+			if (tmpstr && tmpstr > pinputp) {
X+				if (pid > 0 && getsid(pid) != -1) {
X+					svpid = malloc(sizeof(struct spid));
X+					svpid->svpid = pid;
X+					SLIST_INSERT_HEAD(&svs->svpids, svpid,
X+					    next);
X+				}
X+			}
X+		}
X 	}
X-	pclose(pp);
X-
X-	/* Scan the output. We want (see /etc/rc.subr):
X-	 *   ${name} is running as pid $rc_pid.
X-	 * or
X-	 *   ${name} is not running.
X-	 * with $rc_pid being a space-separated list of pids.
X-	 * We cannot scan for the service's name, as the name might be different
X-	 * to the service script name.
X-	 * Though we could assume the service name is properly set in its rc script 
X-	 * and we could thus just parse the script ourselves, exceptions here might 
X-	 * have the same probability as services with different service and script 
X-	 * names.
X-	 * So we have to skip the first portion up to the "is not running" or "is 
X-	 * runnind as pid" and assume service(8) returns the right script's output.
X-	 */
X-	if ((pinputp = strstr(pinput, " is not running.")) != NULL) {
X-		return 1;
X-	} else if ((pinputp = strstr(pinput, " is running as pid ")) == NULL) {
X-		printlog(LOG_ERR, "Could not parse output from `service %s status`. Cause is either a non-standard rc script or (very unlikely) an incompatible rc.subr version.", svs->svname);
X+
X+	retcode = pclose(pp);
X+	if (WEXITSTATUS(retcode)) {
X 		return -1;
X 	}
X-	pinputp = pinputp + 19;
X-
X-	for (pinputp = strtok_r(pinputp, " .\n", &ttmpstr);
X-			pinputp;
X-			pinputp = strtok_r(NULL, " .\n", &ttmpstr)) {
X-		svpid = malloc(sizeof(struct spid));
X-		svpid->svpid = strtoul(pinputp, &tmpstr, 10);
X-		if ((tmpstr && tmpstr[0]) || svpid->svpid <= 0) {
X-			printlog(LOG_ERR, "Invalid output from rc.subr. Could not get all pids.");
X-			free(svpid);
X-			return -1;
X-		}
X-		SLIST_INSERT_HEAD(&svs->svpids, svpid, next);
X-	}
X 
X 	return 0;
X }
X@@ -725,19 +779,41 @@ start_service(struct service *svs)
X 	int ret;
X 	int retcode;
X 	char *cmdstr;
X+	char pinput[LINE_MAX];
X+	FILE *pp;
X 
X-	if (asprintf(&cmdstr, SERVICE " %s " RESTART, svs->svname) <= 0) {
X+	if (asprintf(&cmdstr, SERVICE " %s " START, svs->svname) <= 0) {
X 		if (strerror_r(errno, errorstr, sizeof errorstr))
X-			printlog(LOG_ERR, "asprintf for executing %s failed: %s", svs->svname, errorstr);
X+			printlog(LOG_ERR, "asprintf for executing %s "
X+			    "failed: %s", svs->svname, errorstr);
X 		else
X-			printlog(LOG_ERR, "asprintf for executing %s failed.", svs->svname);
X-		return 0;
X+			printlog(LOG_ERR, "asprintf for executing %s "
X+			    "failed.", svs->svname);
X+		return -1;
X 	}
X 
X-	retcode = system(cmdstr);
X+	pp = popen(cmdstr, "r");
X 	free(cmdstr);
X-	if (WEXITSTATUS(retcode))
X+	if (pp == NULL) {
X+		if (strerror_r(errno, errorstr, sizeof errorstr))
X+			printlog(LOG_ERR, "popen failed: %s", svs->svname,
X+			    errorstr);
X+		else
X+			printlog(LOG_ERR, "popen failed.", svs->svname);
X 		return -1;
X+	}
X+
X+	while (fgets(pinput, sizeof pinput, pp) != NULL) {
X+		if (strstr(pinput, "_enable to YES in") != NULL) {
X+			pclose(pp);
X+			return 1;
X+		}
X+	}
X+	retcode = pclose(pp);
X+
X+	if (WEXITSTATUS(retcode)) {
X+		return -1;
X+	}
X 
X 	/* Refresh our stored pid and re-register with kqueue. */
X 	ret = -1;
X@@ -768,9 +844,11 @@ kqueue_service(struct fscd_cfg *config, struct service *svs)
X 			    EV_ENABLE | EV_ONESHOT, NOTE_EXIT, 0, 0);
X 		if (kevent(config->kq, &kq_events, 1, NULL, 0, NULL) == -1) {
X 			if (strerror_r(errno, errorstr, sizeof errorstr))
X-				printlog(LOG_ERR, "Registering kq event failed");
X+				printlog(LOG_ERR, "Registering kq event "
X+				    "failed");
X 			else
X-				printlog(LOG_ERR, "Registering kq event failed: %s", errorstr);
X+				printlog(LOG_ERR, "Registering kq event "
X+				    "failed: %s", errorstr);
X 			return -1;
X 		}
X 	}
X@@ -785,15 +863,8 @@ kqueue_service(struct fscd_cfg *config, struct service *svs)
X static int
X register_service(struct fscd_cfg *config, struct service *svs)
X {
X-	char errorstr[LINE_MAX];
X-
X-	if (SLIST_EMPTY(&svs->svpids) && fill_pids(svs)) {
X-		if (strerror_r(errno, errorstr, sizeof errorstr))
X-			printlog(LOG_ERR, "Getting pids failed");
X-		else
X-			printlog(LOG_ERR, "Getting pids failed: %s", errorstr);
X-		return -1;
X-	}
X+	if (SLIST_EMPTY(&svs->svpids))
X+		fill_pids(svs);
X 
X 	if (kqueue_service(config, svs))
X 		return -1;
X@@ -823,6 +894,7 @@ unregister_service(struct fscd_cfg *config, char *svc_name_in)
X 				free(svpid);
X 			}
X 			printlog(LOG_INFO, "%s has been removed.", svs->svname);
X+			free(svs->svname);
X 			free(svs);
X 			ret = 0;
X 			break;
X@@ -831,8 +903,8 @@ unregister_service(struct fscd_cfg *config, char *svc_name_in)
X }
X 
X /*
X- * Open the configuration. Read services from that file and start and monitor
X- * them if they are not running.
X+ * Open the configuration. Read services from that file and start and
X+ * monitor them if they are not running.
X  */
X static int
X readconf(struct fscd_cfg *config)
X@@ -849,7 +921,8 @@ readconf(struct fscd_cfg *config)
X 		if (strerror_r(errno, errorstr, sizeof errorstr))
X 			printlog(LOG_ERR, "Opening configuration failed");
X 		else
X-			printlog(LOG_ERR, "Opening configuration failed: %s", errorstr);
X+			printlog(LOG_ERR, "Opening configuration failed: %s",
X+			    errorstr);
X 		return -1;
X 	}
X 
X@@ -867,35 +940,81 @@ readconf(struct fscd_cfg *config)
X 				/* Service already running. Just register. */
X 				svs = make_service(finput);
X 				if (!svs) {
X-					printlog(LOG_ERR, "%s could not be built a structure for.", svs->svname);
X+					printlog(LOG_ERR, "%s could not be "
X+					    "built a structure for.",
X+					    svs->svname);
X 					ret = -1;
X-				} else if (register_service(config, svs)) {
X-					printlog(LOG_ERR, "%s could not be monitored.", svs->svname);
X+				} else if ((ret=register_service(config, svs))) {
X+					if (ret < 0)
X+						printlog(LOG_ERR, "%s could "
X+						    "not be monitored.",
X+						    svs->svname);
X+					else
X+						printlog(LOG_ERR, "%s could "
X+						    "not be monitored. Set "
X+						    "%s_enable to YES in "
X+						    "%cetc/rc.conf.",
X+						    svs->svname, svs->svname,
X+						    '/');
X+					free(svs->svname);
X 					free(svs);
X-					ret = -1;
X+				} else {
X+					printlog(LOG_INFO, "%s is being monitored.",
X+					    svs->svname);
X 				}
X 			}
X 		} else {
X 			if (service_registered(config, finput)) {
X-				/* Service already registered. We should not get to this point! */
X-				printlog(LOG_ERR, "%s is registered, but not running.", finput);
X+				/*
X+				 * Service already registered. We should never
X+				 * get to this point!
X+				 */
X+				printlog(LOG_ERR, "%s is registered, but not "
X+				    "running.", finput);
X 				ret = -1;
X 			} else {
X-				/* Service not running. Try to start and register it. */
X+				/* Service not running. Try to start and register. */
X 				svs = make_service(finput);
X 				if (!svs) {
X-					printlog(LOG_ERR, "%s could not be built a structure for.", svs->svname);
X+					printlog(LOG_ERR, "%s could not be "
X+					    "built a structure for.", svs->svname);
X 					ret = -1;
X-				} else if (start_service(svs)) {
X-					printlog(LOG_ERR, "%s could not be started.", svs->svname);
X+				} else if ((ret=start_service(svs))) {
X+					if (ret < 0)
X+						printlog(LOG_ERR, "%s could "
X+						    "not be started.", svs->svname);
X+					else
X+						printlog(LOG_ERR, "%s could "
X+						    "not be started. Set "
X+						    "%s_enable to YES in "
X+						    "%cetc/rc.conf.",
X+						    svs->svname, svs->svname,
X+						    '/');
X+					free(svs->svname);
X 					free(svs);
X-					ret = -1;
X-				} else if (register_service(config, svs)) {
X-					printlog(LOG_ERR, "%s could not be monitored.", svs->svname);
X+				} else if ((ret=register_service(config, svs))) {
X+					if (ret < 0)
X+						printlog(LOG_ERR, "%s could "
X+						    "not be monitored.",
X+						    svs->svname);
X+					else
X+						printlog(LOG_ERR, "%s could "
X+						    "not be monitored. Set "
X+						    "%s_enable to YES in "
X+						    "%cetc/rc.conf.",
X+						    svs->svname, svs->svname,
X+						    '/');
X+					free(svs->svname);
X 					free(svs);
X-					ret = -1;
X+				} else if ((ret=handle_waiting(config, svs->svname))) {
X+					printlog(LOG_ERR, "%s failed to wait for start.",
X+							svs->svname);
X+					printlog(LOG_ERR, "%s removed from monitoring.",
X+							svs->svname);
X+					unregister_service(config, svs->svname);
X 				} else {
X-					printlog(LOG_INFO, "%s started from config file.", svs->svname);
X+					printlog(LOG_INFO, "%s started from "
X+					    "config file.", svs->svname);
X 				}
X 			}
X 		}
X@@ -920,6 +1039,8 @@ connect_monitor(void *var)
X 	char taskstr[LINE_MAX];
X 	char errorstr[LINE_MAX];
X 
X+	printlog(LOG_INFO, "Server thread started.");
X+
X 	config = var;
X 	memset(&local, 0, sizeof(local));
X 	memset(&remote, 0, sizeof(remote));
X@@ -928,7 +1049,8 @@ connect_monitor(void *var)
X 		if (strerror_r(errno, errorstr, sizeof errorstr))
X 			printlog(LOG_ERR, "Creating socket failed.");
X 		else
X-			printlog(LOG_ERR, "Creating socket failed: %s", errorstr);
X+			printlog(LOG_ERR, "Creating socket failed: %s",
X+			    errorstr);
X 		exit(1);
X 	}
X 
X@@ -939,7 +1061,8 @@ connect_monitor(void *var)
X 			if (strerror_r(errno, errorstr, sizeof errorstr))
X 				printlog(LOG_ERR, "Deleting socket failed.");
X 			else
X-				printlog(LOG_ERR, "Deleting socket failed: %s", errorstr);
X+				printlog(LOG_ERR, "Deleting socket failed: %s",
X+				    errorstr);
X 			exit(1);
X 		}
X 
X@@ -948,15 +1071,18 @@ connect_monitor(void *var)
X 		if (strerror_r(errno, errorstr, sizeof errorstr))
X 				printlog(LOG_ERR, "Binding to socket failed.");
X 		else
X-			printlog(LOG_ERR, "Binding to socket failed: %s", errorstr);
X+			printlog(LOG_ERR, "Binding to socket failed: %s",
X+			    errorstr);
X 		exit(1);
X 	}
X 
X 	if (chmod(socketname, S_IRWXU) == -1) {
X 		if (strerror_r(errno, errorstr, sizeof errorstr))
X-			printlog(LOG_ERR, "Changing socket permissions failed.");
X+			printlog(LOG_ERR, "Changing socket permissions "
X+			    "failed.");
X 		else
X-			printlog(LOG_ERR, "Changing socket permissions failed: %s", errorstr);
X+			printlog(LOG_ERR, "Changing socket permissions "
X+			    "failed: %s", errorstr);
X 		exit(1);
X 	}
X 
X@@ -964,7 +1090,8 @@ connect_monitor(void *var)
X 		if (strerror_r(errno, errorstr, sizeof errorstr))
X 			printlog(LOG_ERR, "Listening to socket failed.");
X 		else
X-			printlog(LOG_ERR, "Listening to socket failed: %s", errorstr);
X+			printlog(LOG_ERR, "Listening to socket failed: %s",
X+			    errorstr);
X 		exit(1);
X 	}
X 
X@@ -978,10 +1105,14 @@ connect_monitor(void *var)
X 				break;
X 			} else if (errno == EINTR || errno == ECONNABORTED) {
X 				if (retries == 0) {
X-					if (strerror_r(errno, errorstr, sizeof errorstr))
X-						printlog(LOG_ERR, "accept retries exhausted.");
X+					if (strerror_r(errno, errorstr,
X+					    sizeof errorstr))
X+						printlog(LOG_ERR, "accept "
X+						    "retries exhausted.");
X 					else
X-						printlog(LOG_ERR, "accept retries exhausted: %s", errorstr);
X+						printlog(LOG_ERR, "accept "
X+						    "retries exhausted: %s",
X+						    errorstr);
X 					exit(1);
X 				} else {
X 					sleep(1);
X@@ -997,10 +1128,14 @@ connect_monitor(void *var)
X 			nbytes = recv(s2, taskstr, sizeof(taskstr), 0);
X 			if (nbytes <= 0) {
X 				if (nbytes == -1) {
X-					if (strerror_r(errno, errorstr, sizeof errorstr))
X-						printlog(LOG_ERR, "receiving from client failed.");
X+					if (strerror_r(errno, errorstr,
X+					    sizeof errorstr))
X+						printlog(LOG_ERR, "receiving "
X+						    "from client failed.");
X 					else
X-						printlog(LOG_ERR, "receiving from client failed: %s", errorstr);
X+						printlog(LOG_ERR, "receiving "
X+						    "from client failed: %s",
X+						    errorstr);
X 				}
X 				done = 1;
X 			}
X@@ -1023,6 +1158,7 @@ handle_task(struct fscd_cfg *config, char *serviceline, int sock_fd)
X 	char *sendstr;
X 	struct service *svs;
X 	char eot = 4;
X+	char status =0;
X 
X 	for (iter = arglst; (*iter = strsep(&serviceline, ":")) != NULL;) {
X 		if (**iter != '\0')
X@@ -1031,53 +1167,82 @@ handle_task(struct fscd_cfg *config, char *serviceline, int sock_fd)
X 	}
X 
X 	pthread_mutex_lock(&config->service_mtx);
X+
X 	/* enable */
X 	if (strcmp(arglst[0], "enable") == 0) {
X 		if (service_registered(config, arglst[1])) {
X 			asprintf(&sendstr, "Service already registered.\n");
X+			status = 1;
X 		} else {
X 			svs = make_service(arglst[1]);
X-			if (!svs)
X-				asprintf(&sendstr, "Error building process structure.\n");
X-			else if (!service_running(svs->svname) && start_service(svs))
X-				asprintf(&sendstr, "Could not start service.\n");
X-			else if (register_service(config, svs))
X-				asprintf(&sendstr, "Could not monitor service.\n");
X-			else
X+			if (!svs) {
X+				asprintf(&sendstr, "Error building process "
X+				    "structure.\n");
X+				status = 1;
X+			} else if (!service_running(svs->svname) &&
X+			    start_service(svs)) {
X+				asprintf(&sendstr, "Could not start "
X+				    "service.\n");
X+				status = 1;
X+			} else if (register_service(config, svs)) {
X+				asprintf(&sendstr, "Could not monitor "
X+				    "service.\n");
X+				status = 1;
X+			} else {
X 				asprintf(&sendstr, "Monitoring service.\n");
X+				status = 0;
X+			}
X 		}
X+		send(sock_fd, &status, 1, 0);
X+		send(sock_fd, sendstr, strlen(sendstr), 0);
X+		send(sock_fd, &eot, 1, 0);
X+		free(sendstr);
X+		pthread_mutex_unlock(&config->service_mtx);
X+		return 0;
X+
X 	/* disable */
X 	} else if (strcmp(arglst[0], "disable") == 0) {
X-		if (unregister_service(config, arglst[1]))
X-			asprintf(&sendstr, "Removing service failed: Not found.\n");
X-		else
X+		if (unregister_service(config, arglst[1])) {
X+			asprintf(&sendstr, "Removing service failed: "
X+			    "Not found.\n");
X+			status = 1;
X+		} else {
X 			asprintf(&sendstr, "Service removed.\n");
X+			status = 0;
X+		}
X+		send(sock_fd, &status, 1, 0);
X+		send(sock_fd, sendstr, strlen(sendstr), 0);
X+		send(sock_fd, &eot, 1, 0);
X+		free(sendstr);
X+		pthread_mutex_unlock(&config->service_mtx);
X+		return 0;
X+
X 	/* shutdown */
X 	} else if (strcmp(arglst[0], "shutdown") == 0) {
X-		pthread_mutex_unlock(&config->service_mtx); /* shutdown needs the lock. */
X-		if (asprintf(&sendstr, "fscd shutting down.\n") <= 0) {
X-			send(sock_fd, &eot, 1, 0);
X-		} else {
X-			send(sock_fd, sendstr, strlen(sendstr), 0);
X-			send(sock_fd, &eot, 1, 0);
X-		}
X-		fscd_shutdown(config, 0);
X+		asprintf(&sendstr, "fscd shutting down.\n");
X+		status = 0;
X+		send(sock_fd, &status, 1, 0);
X+		send(sock_fd, sendstr, strlen(sendstr), 0);
X+		send(sock_fd, &eot, 1, 0);
X+		free(sendstr);
X+		/* We already have the lock, shutdown. */
X+		fscd_shutdown(0);
X+		/*
X+		 * We should never get here, but the unlock helps
X+		 * -Wthread-safety-analysis
X+		 */
X+		pthread_mutex_unlock(&config->service_mtx);
X+		return 0;
X+
X 	/* status */
X 	} else if (strcmp(arglst[0], "status") == 0) {
X 		print_status(config, sock_fd);
X 		pthread_mutex_unlock(&config->service_mtx);
X 		return 0;
X-	} else {
X-		pthread_mutex_unlock(&config->service_mtx);
X-		return -1;
X 	}
X-	pthread_mutex_unlock(&config->service_mtx);
X 
X-	send(sock_fd, sendstr, strlen(sendstr), 0);
X-	send(sock_fd, &eot, 4, 0);
X-	if (sendstr)
X-		free(sendstr);
X-	return 0;
X+	pthread_mutex_unlock(&config->service_mtx);
X+	return -1;
X }
X 
X /*
X@@ -1085,17 +1250,13 @@ handle_task(struct fscd_cfg *config, char *serviceline, int sock_fd)
X  * Empty the list, free all services, close the kqueue, and unlink socket.
X  */
X static void
X-fscd_shutdown(struct fscd_cfg *config, int exitcode)
X+fscd_shutdown(int exitcode)
X {
X 	printlog(LOG_INFO, "fscd shutdown requested.");
X-	/* We want to wait for any pending requests to finish. */
X-	if (config)
X-		pthread_mutex_lock(&config->service_mtx);
X 	(void)unlink(socketname);
X 
X #if defined(__FreeBSD__)
X-	struct pidfh *pfh;
X-	if (pidfile_remove(pfh))
X+	if (pfh && pidfile_remove(pfh))
X 		err(1, "pidfile_remove");
X #endif
X 	exit(exitcode);
X@@ -1103,14 +1264,14 @@ fscd_shutdown(struct fscd_cfg *config, int exitcode)
X 
X /*
X  * Handle a signal.
X- * XXX: Currently, there's no signal handling except for shutting down on the 
X- * registered signals. There might be some in the future.
X+ * XXX: Currently, there's no signal handling except for shutting
X+ * down on the registered signals. There might be some in the future.
X  */
X static void
X handle_sig(int sig)
X {
X 	sig = 1;
X-	fscd_shutdown(NULL, sig);
X+	fscd_shutdown(sig);
X }
X 
X /*
END-of-fsc/files/patch-fscd__fscd.c
echo x - fsc/files/patch-fscadm__fscadm.c
sed 's/^X//' >fsc/files/patch-fscadm__fscadm.c << 'END-of-fsc/files/patch-fscadm__fscadm.c'
Xdiff --git a/fscadm/fscadm.c b/fscadm/fscadm.c
Xindex 53076f5..c6eebc4 100644
X--- fscadm/fscadm.c
X+++ fscadm/fscadm.c
X@@ -69,13 +69,15 @@ static char *socketname = NULL;
X int
X main(int argc, char *argv[])
X {
X-	char *sendstr;
X-	int error = 0;
X-	int ch;
X-	int i;
X+	int ch, i, update, error;
X+	char *sendstr, *tname, buf[80], cname[] = "/etc/fscd.conf";
X+	char tmpname[] = "/tmp/tmpXXXXXXXXXX";
X+	FILE *cfile, *tfile;
X+
X+	error = update = 0;
X 
X 	/* check arguments */
X-	while ((ch = getopt(argc, argv, "Vs:")) != -1)
X+	while ((ch = getopt(argc, argv, "Vs:w")) != -1)
X 		switch (ch) {
X 			case 'V':
X 				version();
X@@ -84,6 +86,9 @@ main(int argc, char *argv[])
X 				if (asprintf(&socketname, "%s", optarg) < 0)
X 					err(1, "asprintf");
X 				break;
X+			case 'w':
X+				update = 1;
X+				break;
X 			default:
X 				usage();
X 				break;
X@@ -97,7 +102,7 @@ main(int argc, char *argv[])
X 		usage();
X 
X 	/* shutdown, status */
X-	if ((strcmp(argv[0], "shutdown") == 0) 
X+	if ((strcmp(argv[0], "shutdown") == 0)
X 			|| (strcmp(argv[0], "status") == 0)) {
X 		if (argc != 1)
X 			usage();
X@@ -112,12 +117,40 @@ main(int argc, char *argv[])
X 				warn("asprintf");
X 				continue;
X 			}
X-
X 			error += daemonconnect(sendstr);
X 			free(sendstr);
X 		}
X+		if (update) {
X+			if (strcmp(argv[0], "enable") == 0) {
X+				cfile = fopen(cname, "a+");
X+				if (cfile != NULL) {
X+					if (fputs(argv[1], cfile) == EOF)
X+						warnx("Unable to write to configuration");
X+					if (fclose(cfile) != 0)
X+						warnx("Unable to close configuration file");
X+				}
X+			} else {
X+				tname = mktemp(tmpname);
X+				cfile = fopen(cname, "r");
X+				tfile = fopen(tname, "w");
X+				if ((cfile == NULL) || (tfile == NULL))
X+					warnx("Unable to open configuration file");
X+				while (fgets(buf, 80, cfile) != NULL) {
X+					if (strncmp(buf, argv[1], strlen(argv[1])) == 0) {
X+						continue;
X+					} else {
X+						if (fputs(buf, tfile) == EOF)
X+							warnx("Unable to write configuration");
X+					}
X+				}
X+			}
X+			if ((fclose(cfile) != 0) || (fclose(tfile) != 0))
X+				warnx("Unable to close configuration file");
X+			rename(tname, cname);
X+		}
X+
X 	} else {
X-		warnx("unknown command: %s", argv[0]);
X+		warnx("unknown option: %s", argv[0]);
X 		usage();
X 	}
X 
X@@ -137,7 +170,8 @@ usage(void)
X 			"\n"
X 			"options:\n"
X 			"        -V   Print out version.\n"
X-			"        -s S Use socket S instead of standard.\n " );
X+			"        -s S Use socket S instead of the default.\n"
X+			"        -w   Write the status change to fscd.conf\n");
X 	exit(EX_USAGE);
X }
X 
X@@ -158,9 +192,13 @@ version(void)
X int
X daemonconnect(char *task)
X {
X-	int s, len, nbytes, retcode = 0;
X+	int s, len, nbytes, retcode, total;
X 	struct sockaddr_un remote;
X 	char recdata[LINE_MAX];
X+	char *ptr;
X+
X+	retcode = 1;
X+	total = 0;
X 
X 	if ((s = socket(PF_LOCAL, SOCK_STREAM, 0)) == -1)
X 		err(EX_OSERR, "socket");
X@@ -169,6 +207,7 @@ daemonconnect(char *task)
X 	strncpy(remote.sun_path, socketname ? socketname : SOCK_PATH,
X 			sizeof remote.sun_path);
X 	len = strlen(remote.sun_path) + sizeof(remote.sun_family) + 1;
X+
X 	if (connect(s, (struct sockaddr *)&remote, len) == -1)
X 		err(EX_OSERR, "connect");
X 
X@@ -176,16 +215,22 @@ daemonconnect(char *task)
X 		err(EX_OSERR, "send");
X 
X 	do {
X-		memset(recdata, 0, sizeof(recdata));
X 		nbytes = recv(s, recdata, sizeof(recdata) - 1, 0);
X-		if (nbytes > 0)
X-			printf("%s", recdata);
X-	} while (recdata[strlen(recdata) - 1] != 4); /* 4 = EOT */
X-
X-	if (nbytes < 0) {
X-		warn("recv");
X-		retcode = nbytes;
X-	}
X+		if (nbytes <= 0) {
X+			if (nbytes < 0) {
X+				warn("recv");
X+			}
X+			break;
X+		}
X+		ptr = recdata;
X+		if (!total) {
X+			retcode = recdata[0];
X+			ptr++;
X+		}
X+		total += nbytes;
X+		recdata[nbytes] = '\0';
X+		printf("%s", ptr);
X+	} while (recdata[nbytes - 1] != 4); /* 4 = EOT */
X 
X 	close(s);
X 	return retcode;
END-of-fsc/files/patch-fscadm__fscadm.c
echo x - fsc/files/patch-rc.d_fscd
sed 's/^X//' >fsc/files/patch-rc.d_fscd << 'END-of-fsc/files/patch-rc.d_fscd'
Xdiff --git a/rc.d/fscd b/rc.d/fscd
Xindex 1da5be3..74c6572 100755
X--- rc.d/fscd
X+++ rc.d/fscd
X@@ -8,13 +8,20 @@
X # PROVIDE: fscd
X # REQUIRE: DAEMON syslogd
X # BEFORE:  NETWORKING LOGIN
X-# KEYWORD: shutdown
X+# KEYWORD: nojail shutdown
X 
X . /etc/rc.subr
X 
X name="fscd"
X-command="/usr/sbin/${name}"
X+desc="FreeBSD Services Control Daemon"
X+rcvar="fscd_enable"
X+command="/usr/local/sbin/${name}"
X pidfile="/var/run/${name}.pid"
X+required_files="/usr/local/etc/$name.conf"
X 
X load_rc_config $name
X+: ${fscd_enable="NO"}
X+: ${fscd_flags=""}
X+command_args="-d"
X+
X run_rc_command "$1"
END-of-fsc/files/patch-rc.d_fscd
echo x - fsc/distinfo
sed 's/^X//' >fsc/distinfo << 'END-of-fsc/distinfo'
XSHA256 (fsc-1.0.1.tar.gz) = 41979af3f5ed2fd37e30839cacc22408ac65f2fd20df30de1e5114bc0d2e733b
XSIZE (fsc-1.0.1.tar.gz) = 12435
END-of-fsc/distinfo
echo x - fsc/pkg-descr
sed 's/^X//' >fsc/pkg-descr << 'END-of-fsc/pkg-descr'
XThe FreeBSD Services Control software provides service
Xmonitoring, restarting, and event logging for FreeBSD
Xservers.  The core functionality is a daemon (fscd)
Xwhich is interfaced with using fscadm.  See manual pages
Xfor more information.
END-of-fsc/pkg-descr
exit

